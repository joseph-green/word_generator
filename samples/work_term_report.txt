The University of Waterloo
Faculty of Mathematics



Analyzing the Effects of Implementing a Microservice Architecture in Finastra’s Current Product Suite



Finastra
Mississauga, Ontario


Prepared By:
Joseph Green
1B Computer Science
 ID 20704601
July 10th, 2018


Letter of Submittal

Joseph Green

July 10th, 2018

Evaluators
WatPD
University of Waterloo
Waterloo, Ontario
N2L 3G1

Dear Evaluators:

The following report was prepared for the PD11 course and as my first work term report. The report, titled “Analyzing the Effects of Implementing a Microservice Architecture in Finastra’s Current Product Suite”, explores the benefits and costs of implementing a microservices architecture at Finastra, considering the effects that it may have on design, development, testing, and deployment.
Finastra is one of the world’s largest providers of financial technology solutions with offices worldwide. Formed as a merger of companies Davis + Henderson and Misys, it is currently the third-largest financial technology company globally. 
The team that I worked on develops the Collateral Guard Enterprise (CGe) product, which allows creditors to manage liens on North American lien registries. It provides a public API and user interface for clients to create, view, edit and delete liens on these registries. The team was managed by Claudiu Tomescu and includes 8 members, mostly developers.
I assure that this report is entirely my own work and has not been submitted previously for academic credit. I’d like to also thank Claudiu Tomescu and Muskan Aulakh for their guidance and previous work on microservices, which influenced my decision to pursue this topic. No other assistance was provided.

Regards,
Joseph Green ID 20704601


Table of Contents
LIST OF FIGURES										3
EXECUTIVE SUMMARY									4
 INTRODUCTION									5
	1.1 Finastra and the CGe Product							5
	1.2 Monolithic Application Architecture						5
	1.3 Microservices									6
	1.4 Purpose										8
ANALYSIS										
Benefits of Switching to a Microservice Architecture				9
Implementation of New Features					9
Security								10
Specialization of Teams						10
Scalability 								11
Costs of Switching to a Microservice Architecture					12
Extracting Microservices from Existing Application			12
Restructuring of Development teams					13
Retraining of Developers						14
CONCLUSION										15
RECOMMENDATIONS									16
REFERENCES										17
ACKNOWLEDGEMENTS									18

List of Figures
Figure 1 - Comparison in between microservice and monolithic architecture		8

Executive Summary
Finastra is an international financial technology company, which offers a broad range of financial services to banks and credit unions. These services include Collateral Guard Enterprise (CGe), which allows creditors to manage their liens that are registered in North American lien registries (Finastra, 2017). 
Currently, the CGe application employs a monolithic code structure, which is defined as an application that is “built as a single unit”. (Mulesoft). The nature of monolithic programs cause many problems, especially as the program increases in size and complexity.
Microservices are a recent alternative to monoliths that challenge solve some of the problems with monolithic infrastructures. Microservices are defined as a cluster of very simple, focused applications working in unison (Kharenko, 2015).
This report performs a cost-benefit analysis of switching the CGe product from a monolithic architecture to microservices.
Overall, four key benefits of microservies were identified: easier implementation of new features, increased security, increased specialization of teams, and increased scalability
Costs of making the paradigm switch include the extraction of microservices from the current application, restructuring of teams and the retraining of employees.
In sum, the report concludes that transferring the CGe product over from a monolithic architecture to a microservice-based one will result in a more productive, more secure, and more scalable application. Therefore, it is strongly recommended that Finastra looks to transform the existing CGe product to microservices, and develop new features using the new architecture.




1.0 Introduction

1.1 Finastra and the CGe Product
Formed in a 2017 merger of firms Misys and Davis + Henderson, Finastra is one the world’s largest financial technology companies. It offers an entire suite of financial services to its consumers, which are mostly banks and credit unions, in dozens of countries worldwide (Finastra, 2017).

Collateral Guard Enterprise (CGe) is one of the many financial services that Finastra provides to its client base. The CGe product allows creditors to more easily manage the liens that they offer to their customers (Collateral Guard Enterprise). A lien is a right given to the creditor that allows them to seize a particular asset, known as collateral, if the debtor does not meet some requirement of the loan agreement (e.g. not repaying their loan on time) (Pritchard, 2018). Liens in North America are maintained on a series of registries (e.g. PPSA), which keeps track of all necessary information involved in a lien (creditors, debtors, collateral, etc.) (Pritchard, 2018).

1.2 Monolithic Application Architecture
Like many other companies dealing with traffic at a similar scale, Finastra has an immense code base consisting of hundreds of thousands of lines of code across its offerings. Many of the company’s products have a monolithic code structure, meaning the entire application is contained inside of a single file system which is then run on a server or distributed to customers. (Mulesoft). New features are added by making modifications to the existing monolith. This method of producing software is ineffective, and leads to many problems across the development process, as discussed later in the report.

At the time of writing of this report, the CGe product, as well as a large majority of the products offered by Finastra exist as monolithic applications. 

1.3 Microservices
In recent years, an alternative to the traditional monolithic code structure has taken hold in the tech community: microservices. The microservices architecture is a design paradigm which divides the functionality of one monolithic program into a “cluster” of many smaller programs. (Mazzari et al., 2016).  Figure 1 details the differences in between microservice and monolithic architecture.


Figure 1 – Comparison in between microservice and monolithic architecture (Malav, B., 2017)


A microservice, as defined by researchers at Innopolis University (2016), are characterized by the following:

Bounded Context: microservices serve a single, focused business purpose 
Size: a microservice is small enough to maintain, scale, or replace easily
Independency: microservices should be loosely coupled and be able to operate without other microservices

This design approach has been adopted by large corporations like Netflix (Mauro, 2015) and CIBC (Wood, 2017) with a lot of success. However, the problem for many developers and organizations who look to adopt a microservice architecture is how to implement the new approach to their own legacy systems. The interdependence and size of the current applications makes them hard to break down into smaller programs, and it is difficult to decide where and how new microservices should be added (Fowler, 2018). Moreover, changes to the way code is designed, implemented, tested and released must be put in place to adapt to this new paradigm. Sometimes, it is even too costly and time-intensive for an existing product to be redesigned using microservices. 

1.4 Purpose
This report first looks to analyze the current state of one of Finastra’s solutions, Collateral Guard Enterprise (CGe), and analyzes the benefits and costs of implementing a microservice architecture in its application.
Finally, the report concludes whether implementing a microservice architecture in the CGe product is worthwhile, and provides recommendations of how the new architecture should be implemented, if at all. 


2.0 Analysis

2.1 Benefits of Implementing a Microservice Architecture
This section will analyze several problems that are associated with a large monolithic application and introduce how microservices solve these problems. 

2.1.1 Implementation of New Features
When the CGe team looks to add new features to its application, many things must be considered before new functionality is integrated into the existing application. For instance, if you wanted to completely refactor a certain function in your code, you must concern yourself with how that function interacts with every other piece of code in your application, to make sure that the function retains its old behavior (Nordstrom, 2016). In a monolithic system this can be quite troublesome, as functions can be used by multiple parts of the same application. The same problem applies with the development of new features in the application. (Nordstrom, 2016)

With microservices, since there is low coupling in between services, it is easy to refactor individual functionality as the risk of breaking other parts of the code base when refactoring is greatly reduced (Kharenko, 2015). This allows you to make improvements to your application quickly and robustly, without having to worry about how it may affect others pieces of code. Moreover, if you look to completely redesign an entire feature, microservice architecture gives you the opportunity to remove an entire microservice and replace it with another.

2.1.2 Security
While applications built on a monolithic architecture are no more prone to breaches than microservices, they stand to lose a lot more data in the case that a breach does happen. Since all the functionality of a monolithic system is deeply intertwined, gaining access to one part of the program means gaining access to many other parts of the application too. (Mulesoft)

Microservices keep the application secure by spreading the data out into many different locations that must be breached individually (Mulesoft). Consider the situation like keeping a large sum of money in a bank vault, versus many smaller safe deposit boxes. A thief must break the lock in both cases, but with microservices, not all is lost if you’re robbed.

2.1.3 Specialization of Teams
Monolithic applications, especially large ones, require many people to work on them in order to develop new features and fix bugs. However, since all of these people are working on a single application, problems can arise. First, keeping people organized and assigning them proper work is a daunting task for project managers. Next, since the programmers that work on the product have to consider how their code affects different parts of the monolith, they must have an unnecessarily thorough understanding about what everything in the application does, whether they work directly on it or not. These problems are a drag on productivity, and as a result, the application is slower to develop new features.

Microservices, however, offer a way to improve the workflow of teams. Since microservices are small applications in a larger solution, you can transfer that philosophy to how you divide work as well. Instead of having one large development team, you can create many smaller, more focused groups (Kharenko, 2015). This way, not only are a developer’s duties more concentrated on a few microservices, but also there is less worry about knowing exactly how other microservices work. As long as the structure of the data being passed between microservices stays the same.

2.1.4 Scalability 
With monolithic applications, scaling the app up and down is done absolutely: you must add or remove computing power to the entire product. This is a problem if you only want to scale up or down a single part of the application. 

Also, since traffic to an application fluctuates, there is a lot of guesswork required to make sure there are enough servers to handle day-to-day traffic. A common strategy for companies with monolithic apps is to overcompensate for expected traffic, providing more servers than necessary. This approach is wasteful and not cost-efficient.

Microservices solve the problem of scalability as companies can dedicate more or less computing power to a single microservice. Therefore, companies can more accurately allocate servers, based on the needs of a single area of their product. This approach leads to a more efficient use of resources and lower costs for the company.

2.2 Costs of Implementing a Microservice Architecture
This section will look at what changes must be put in place in order to ensure success of a microservice architecture at Finastra. 

2.2.1 Extraction of Microservices from Existing Product
 In order to get the most from having a microservice architecture, CGe must break down its current monolithic product into many different microservices that each perform a very narrow task within the solution. For some code bases, extraction is very difficult, as the functions for a candidate microservice are sometimes spread out amongst multiple files and more than one candidate microservice may depend on a single resource (e.g. a database).

In the case of CGe, there are many services that already serve a cohesive purpose. These services would serve very well as a microservice, and are easy to extract from the code base. 

Contrarily, other areas of the application, such as the API, are hard to break down due to the Model-View-Controller structure, which means that a microservice would be split amongst several files, all in different directories. Therefore, it is not worthwhile to break down this part of the application.

Overall, while the current product cannot be broken down into perfectly granular microservices, it can make process towards a more microservice-oriented product. 

2.2.2 Restructuring of Development Teams
As discussed in Section 1.1.3, implementing a microservice architecture will allow teams to be more specialized and focused on a certain area of the business. That being considered, there must be a restructuring of the CGe team in order to accommodate for the new style of development. Instead of the typical seven or eight members per team, new teams must be formed with 2-3 members each.

Moreover, management of these teams will change in accordance with the shift in paradigm. The current CGe structure has a single “team leader” for each development team. With the implementation of microservices, a manager may have to look over two or three different teams.

2.2.3 Retraining of Developers 
Since microservice architecture is a fairly recent development, and many of CGe’s current employees are not currently trained to develop software in the new paradigm. Therefore, it is essential that all developers on the CGe product know how to make cohesive, well-designed microservices. This implies that all developers on the CGe team must be retrained for the new design practice. 
3.0 Conclusion
After analyzing the problems plaguing CGe’s current infrastructure, and the potential benefits that microservices present in solving those problems, it is concluded that switching to a microservice architecture will bring a net gain to CGe’s operations.

4.0 Recommendations
Based on my analysis of the potential solutions that microservices offer to the problems associated with Finastra’s current monolithic solution, I strongly recommend that Finastra implements a microservice-centric design approach in the future and looks to convert their existing monolithic product offerings into microservice-based ones.
References
Kharenko, A. (2015). Monolithic vs. Microservices Architecture. Retrieved from: https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59
Malav, B (2017). Microservices vs. Monolithic architecture. Retrieved from: https://medium.com/startlovingyourself/microservices-vs-monolithic-architecture-c8df91f16bb4
Newman, S. (2015) Building Microservices: Designing Fine-Grained Systems Sebastopol, CA: O’ Reilly
Mazzara, M., Mustafin, R., Safina L., Lanese I. (2016) Towards Microservices and Beyond. Innopolis, Russia
Mauro, T (2015). Adopting Microservices at Netflix: Lessons For Architectural Design. Nginx Blog. Retrieved from: https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/  
Pritchard, J. (2018). Liens: What They Are and How They Work. The Balance. Retrieved from https://www.thebalance.com/liens-what-they-are-and-how-they-work-315611
Finastra (2017). Our Story. Retrieved from: https://www.finastra.com/about/our-story
PPSA.ca. Frequently Asked Questions. Retrieved from: http://www.ppsa.ca/ppsacaV3/general/faq.jsp
Mulesoft. Microservices vs. Monolithic architecture. Retrieved from: https://www.mulesoft.com/resources/api/microservices-vs-monolithic
Mulesoft. Microservices and Security: Increasing Security by Increasing Surface Area. Retrieved from: https://www.mulesoft.com/resources/api/microservices-security
Nordstrom, J. (2016) Architecting for Speed: How Agile Innovators Accelerate Growth through Microservices. LinkedIn. Retrieved from:  https://www.linkedin.com/pulse/architecting-speed-how-agile-innovators-accelerate-growth-nordstr%C3%B6m/
Collateral Guard Enterprise. Welcome to Collateral Guard. Retrieved from: https://www.collateralguard.dh.com/
Wood, C. (2017) Creating a Microservices Framework at CIBC: A Case Study. Nordic APIs Retrieved from: https://nordicapis.com/creating-a-microservices-framework-at-cibc-a-case-study/
Fowler, M. (2018) How to Break a Monolith into Microservices. Retrieved from: https://martinfowler.com/articles/break-monolith-into-microservices.html




Acknowledgements
I would like to acknowledge Claudiu Tomescu, my manager and peer mentor at Finastra, for his guidance about navigating the nascent technology of microservices and vital information about the structure of the Collateral Guard product.
I also thank Muskan Aulakh for her work on the containerization of the CGe product, which helped me understand some of the key concepts of microservices. 
